[
    {
        "Question": "Which command in Bash executes the last line in the shell history that starts with ls?",
        "Bash script": "",
        "Answer A": "!",
        "Answer B": "!!",
        "Answer C": "!\\*",
        "Answer D": "!ls",
        "Correct Answer": "!ls",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": 1
    },
    {
        "Question": "What is the key difference between a redirect (>) and piping to the tee command?",
        "Bash script": "",
        "Answer A": "The tee command sends output only to STDOUT and STDERR.",
        "Answer B": "A redirect sends output to STDOUT and a file, whereas a tee sends output only to STDOUT.",
        "Answer C": "Nothing, they are the same.",
        "Answer D": "The tee command sends output to STDOUT and a file, whereas a redirect sends output only to a file.",
        "Correct Answer": "The tee command sends output to STDOUT and a file, whereas a redirect sends output only to a file.",
        "Category": "Shell Scripting",
        "Answer_color": "green",
        "User answer": 3
    },
    {
        "Question": "In the Bash shell, what is the difference between piping into | and piping into |&?",
        "Bash script": "",
        "Answer A": "Piping into | pipes both stdout and stderr. Piping into |& pipes only stderr.",
        "Answer B": "Piping into | pipes stdout. Piping into |& pipes stdout and stderr.",
        "Answer C": "Piping into | pipes both stdout and stderr. Piping into |& pipes only stdout.",
        "Answer D": "Piping into | pipes stdout. Piping into |& pipes all open file descriptors.",
        "Correct Answer": "Piping into | pipes stdout. Piping into |& pipes stdout and stderr.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": 0
    },
    {
        "Question": "With most GNU commands, if an option is a word, what will it be preceded by?",
        "Bash script": "",
        "Answer A": "two dashes",
        "Answer B": "a backslash",
        "Answer C": "one dash",
        "Answer D": "nothing",
        "Correct Answer": "two dashes",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What would happen if you have a script file named script that takes a long time to complete, and you type `nohup ./script &` in the command line?",
        "Bash script": "",
        "Answer A": "The script will remain running in the background even if you reboot the system.",
        "Answer B": "The script will run in your terminal and you will not be able to do anything until it completes.",
        "Answer C": "The script will run in the background until you end the session.",
        "Answer D": "The script will run in the background and will continue running even if you end the session.",
        "Correct Answer": "The script will run in the background and will continue running even if you end the session.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What will this command print?",
        "Bash script": "echo \"Thu Jun 4 15:45:45 PDT 2020\" | cut -f3 -d\" \"",
        "Answer A": "It will print nothing.",
        "Answer B": "Thu Jun 4 15:45:45 PDT 2020",
        "Answer C": "0.6567708333333333",
        "Answer D": "4",
        "Correct Answer": "4",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "How can you improve this code snippet?",
        "Bash script": "if ls /etc/passwd &> /dev/null\nthen\n\techo \"exists\"\nfi",
        "Answer A": "The code snippet cannot be improved, this is a valid way of checking for the existence of a file.",
        "Answer B": "Use Bash's built-in `[[ ]]` test conditions instead of the ls command.",
        "Answer C": "The redirect to `/dev/null` will silence the return code invalidating the conditional. Removing the redirect will solve this.",
        "Answer D": "The ls command will output the name of the file to the screen. Running ls in quiet mode will improve the code snippet.",
        "Correct Answer": "Use Bash's built-in `[[ ]]` test conditions instead of the ls command.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What will not happen if you run the make command without parameters?",
        "Bash script": "",
        "Answer A": "It will clean up all previously generated binaries and perform a new build.",
        "Answer B": "It will run rules of compilation and building.",
        "Answer C": "It will look for a file called makefile in your current directory.",
        "Answer D": "It will build only programs that need to be rebuilt.",
        "Correct Answer": "It will clean up all previously generated binaries and perform a new build.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What is the command to create an associative array in Bash?",
        "Bash script": "",
        "Answer A": "declare -a",
        "Answer B": "aarray",
        "Answer C": "array -a",
        "Answer D": "declare -A",
        "Correct Answer": "declare -A",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What is the difference the `==` and `=~` comparison operators when used in BASH double square bracket `if` conditionals?",
        "Bash script": "",
        "Answer A": "The `==` operator performs a string comparison; `=~` performs a regex comparison.",
        "Answer B": "The `==` operator performs a string comparison; `=~` performs a glob pattern comparison.",
        "Answer C": "The `=~` operator performs a string comparison; `==` performs a regex comparison.",
        "Answer D": "There is no `=~` operator in BASH `if` conditionals.",
        "Correct Answer": "The `==` operator performs a string comparison; `=~` performs a regex comparison.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What is the difference between these two lines of code?",
        "Bash script": "echo \"data\" | tee -a file.txt\necho \"data\" >> file.txt",
        "Answer A": "The first line will append the word `data` to file.txt and output it on the screen. The second line will append the word `data` only to file.txt.",
        "Answer B": "They are the same.",
        "Answer C": "The first line will append the word `data` to file.txt and there will be no output on the screen. The second line will output the word `data` on the screen and append it to `file.txt`",
        "Answer D": "Both lines will overwrite file.txt with the word data.",
        "Correct Answer": "The first line will append the word `data` to file.txt and output it on the screen. The second line will append the word `data` only to file.txt.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What would be in out.txt?",
        "Bash script": "cat < in.txt > out.txt",
        "Answer A": "the content of in.txt.",
        "Answer B": "the output from the command line.",
        "Answer C": "Nothing, because you cannot redirect from a file (in.txt) to another file (out.txt). You can redirect only from a command to a file.",
        "Answer D": "Nothing, The redirect will create a new empty file, but there will not be any output from the cat command to redirect.",
        "Correct Answer": "the content of in.txt.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "Which of these features is missing from the Bash Language?",
        "Bash script": "",
        "Answer A": "associative arrays.",
        "Answer B": "extended regular expressions.",
        "Answer C": "debug traps.",
        "Answer D": "object orientation.",
        "Correct Answer": "object orientation.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "What is the first step to integrate extended globs into your command-line workflow?",
        "Bash script": "",
        "Answer A": "Nothing, extended globs are already integrated into the shell and turned on automatically.",
        "Answer B": "Make extended globs persistent by adding `shopt -s extglob` to a shell startup file.",
        "Answer C": "Type `shopt -s extglob` into a shell one time to set the option on permanently.",
        "Answer D": "Make extended globs persistent by adding `shopt +s extglob` to a shell startup file.",
        "Correct Answer": "Make extended globs persistent by adding `shopt -s extglob` to a shell startup file.",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "Which variable contains last background job process id?",
        "Bash script": "",
        "Answer A": "`$!`",
        "Answer B": "`$$`",
        "Answer C": "`$?`",
        "Answer D": "`$*`",
        "Correct Answer": "`$!`",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "In which Linux shell script positional parameter is the script itself stored?",
        "Bash script": "",
        "Answer A": "$2",
        "Answer B": "$1",
        "Answer C": "$0",
        "Answer D": "$9",
        "Correct Answer": "$0",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "In a shell script, to create an infinite while loop, make the condition always return true by using the **\\_** command for the while loop condition.",
        "Bash script": "",
        "Answer A": "return",
        "Answer B": "continue",
        "Answer C": "true",
        "Answer D": "always",
        "Correct Answer": "true",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "In BASH parsing, which expansion happens first?",
        "Bash script": "",
        "Answer A": "brace expansion",
        "Answer B": "variable expansion",
        "Answer C": "filename expansion (globbing)",
        "Answer D": "word splitting",
        "Correct Answer": "brace expansion",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "Which of the following types is not a default type of input/output in Linux?",
        "Bash script": "",
        "Answer A": "standard error",
        "Answer B": "standard input",
        "Answer C": "standard output",
        "Answer D": "standard file",
        "Correct Answer": "standard file",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "In a shell script, **\\_** means OR.",
        "Bash script": "",
        "Answer A": "||",
        "Answer B": "&",
        "Answer C": "|",
        "Answer D": "&&",
        "Correct Answer": "||",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    },
    {
        "Question": "On a Linux or Unix system using X Window, the GVim \\* register **\\_**.",
        "Bash script": "",
        "Answer A": "contains text that is highlighted or selected with the mouse",
        "Answer B": "is the same thing as the + register",
        "Answer C": "is unused",
        "Answer D": "contains all yank, delete, change, and put operations",
        "Correct Answer": "contains text that is highlighted or selected with the mouse",
        "Category": "Shell Scripting",
        "Answer_color": "red",
        "User answer": null
    }
]